"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DevDeployHooks = void 0;
const tapable_1 = require("tapable");
const SpDevDeploy_1 = require("./SpDevDeploy");
const node_core_library_1 = require("@rushstack/node-core-library");
const DevDeployHelper_1 = require("./DevDeployHelper");
const PluginNames = __importStar(require("../PluginNames"));
const AzureUploader_1 = require("../../utilities/AzureUploader");
/**
 * @public
 */
class DevDeployHooks {
    constructor() {
        /**
         * Initialize
         */
        this.init = new tapable_1.AsyncParallelHook(['deployOptions']);
        /**
         * Perform any pre processing such as delete any existing deployment info json, clean up dist folder, etc.
         */
        this.preProcess = new tapable_1.SyncHook();
        /**
         * Gets the files to be deployed to the CDN
         */
        this.getFiles = new tapable_1.AsyncSeriesWaterfallHook([
            'files'
        ]);
        /**
         * Gets the name of the folder in the container into which files should be uploaded
         */
        this.getContainerFolderName = new tapable_1.SyncWaterfallHook([
            'containerFolderName'
        ]);
        /**
         * Gets the name of the Azure storage account
         */
        this.getStorageAccountName = new tapable_1.SyncWaterfallHook([
            'storageAccountName'
        ]);
        /**
         * Gets the name of the container
         */
        this.getContainerName = new tapable_1.SyncWaterfallHook(['containerName']);
        /**
         * Gets a SAS for the storage container
         */
        this.getStorageSas = new tapable_1.AsyncSeriesWaterfallHook([
            'storageSas'
        ]);
        /**
         * Returns true if the deployment is in a prod environment
         */
        this.isProd = new tapable_1.SyncWaterfallHook(['isProd']);
        /**
         * Perform any post processing, usually print the deploy link, save deployment info json, collect library files, etc.
         */
        this.postProcess = new tapable_1.AsyncSeriesHook();
    }
}
exports.DevDeployHooks = DevDeployHooks;
/**
 * @internal
 */
class DevDeployPlugin {
    constructor() {
        this.pluginName = PluginNames.DevDeployPlugin;
    }
    get accessor() {
        if (!this._accessor) {
            this._accessor = {
                hooks: new DevDeployHooks(),
                properties: {}
            };
        }
        return this._accessor;
    }
    apply(heftSession, heftConfiguration) {
        heftSession.registerAction({
            actionName: 'dev-deploy',
            documentation: 'Deploy the current project, and optionally the whole repo, to a testing CDN.',
            parameters: {
                rush: {
                    kind: 'flag',
                    parameterLongName: '--rush',
                    description: 'If specified, deploy the whole rush repository instead of just the current project.'
                },
                maxRetries: {
                    kind: 'integer',
                    parameterLongName: '--max-retries',
                    description: 'Overrides the default maximum number of upload retries.'
                }
            },
            callback: async (parameters) => {
                const logger = heftSession.requestScopedLogger('dev-deploy-plugin');
                logger.terminal.writeLine('Starting DevDeploy...');
                this._installDefaultHooks();
                try {
                    await this._deployAsync({
                        useRush: parameters.rush,
                        maxRetries: parameters.maxRetries,
                        terminal: logger.terminal,
                        rootPath: heftConfiguration.buildFolder
                    });
                    logger.terminal.writeLine(node_core_library_1.Colors.green('DevDeploy completed successfully.'));
                }
                catch (e) {
                    logger.emitError(e);
                }
            }
        });
    }
    _installDefaultHooks() {
        const hooks = this.accessor.hooks;
        let devDeployProcessor;
        hooks.init.tapPromise(PluginNames.DevDeployPlugin, async (options) => {
            devDeployProcessor = await SpDevDeploy_1.SpDevDeploy.initializeAsync({
                _manifestsJsFileMetadata: this.accessor.properties._manifestsJsFileMetadata,
                ...options
            });
        });
        hooks.preProcess.tap(PluginNames.DevDeployPlugin, () => {
            devDeployProcessor.preProcess();
        });
        hooks.getContainerFolderName.tap(PluginNames.DevDeployPlugin, () => {
            return SpDevDeploy_1.SpDevDeploy.getDevDeployContainerDirectoryName();
        });
        hooks.isProd.tap(PluginNames.DevDeployPlugin, () => {
            return false;
        });
        hooks.getFiles.tapPromise(PluginNames.DevDeployPlugin, async () => {
            return await devDeployProcessor.getFilesAsync();
        });
        hooks.postProcess.tapPromise(PluginNames.DevDeployPlugin, async () => {
            devDeployProcessor.postProcess();
        });
    }
    async _deployAsync(options) {
        const hooks = this.accessor.hooks;
        const accountName = hooks.getStorageAccountName.call();
        const sas = await hooks.getStorageSas.promise();
        const isProd = hooks.isProd.call(false);
        const containerName = hooks.getContainerName.call();
        const folderNameInContainer = hooks.getContainerFolderName.call();
        if (!accountName) {
            throw new Error('Azure storage account not set.');
        }
        if (!sas) {
            throw new Error('Azure storage account SAS not set.');
        }
        if (!containerName) {
            throw new Error('Azure container name not set.');
        }
        const deployConfig = {
            accountName,
            sas,
            isProd,
            containerName,
            folderNameInContainer,
            useRush: options.useRush,
            maxRetries: options.maxRetries || AzureUploader_1.AzureUploader.DEFAULT_AZURE_MAX_NUMBER_OF_RETRIES
        };
        await hooks.init.promise({
            isolateProjects: false,
            rootPath: options.rootPath,
            terminal: options.terminal,
            devDeployConfig: deployConfig
        });
        hooks.preProcess.call();
        const deployData = await hooks.getFiles.promise();
        await DevDeployHelper_1.DevDeployHelper.deployFilesAsync(options.terminal, deployConfig, deployData);
        await hooks.postProcess.promise();
    }
}
exports.default = new DevDeployPlugin();
//# sourceMappingURL=DevDeployPlugin.js.map