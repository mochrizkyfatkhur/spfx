import { __awaiter, __extends, __generator } from "tslib";
import { Batch } from "@pnp/odata";
import { Logger } from "@pnp/logging";
import { assign, jsS, isUrlAbsolute, hOP, DefaultRuntime } from "@pnp/common";
import { GraphHttpClient } from "./graphhttpclient.js";
import { toAbsoluteUrl } from "./utils/toabsoluteurl.js";
var GraphBatch = /** @class */ (function (_super) {
    __extends(GraphBatch, _super);
    function GraphBatch(batchUrl, maxRequests, runtime) {
        if (batchUrl === void 0) { batchUrl = "v1.0/$batch"; }
        if (maxRequests === void 0) { maxRequests = 20; }
        if (runtime === void 0) { runtime = DefaultRuntime; }
        var _this = _super.call(this) || this;
        _this.batchUrl = batchUrl;
        _this.maxRequests = maxRequests;
        _this.runtime = runtime;
        return _this;
    }
    GraphBatch.prototype.setRuntime = function (runtime) {
        this.runtime = runtime;
        return this;
    };
    GraphBatch.prototype.executeImpl = function () {
        return __awaiter(this, void 0, void 0, function () {
            var client, requests, _loop_1, this_1;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        Logger.write("[" + this.batchId + "] (" + (new Date()).getTime() + ") Executing batch with " + this.requests.length + " requests.", 1 /* Info */);
                        if (this.requests.length < 1) {
                            Logger.write("Resolving empty batch.", 1 /* Info */);
                            return [2 /*return*/, Promise.resolve()];
                        }
                        client = new GraphHttpClient(this.runtime);
                        requests = this.requests.slice();
                        _loop_1 = function () {
                            var requestsChunk, batchRequest, batchOptions, queryUrl;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        requestsChunk = requests.splice(0, this_1.maxRequests);
                                        batchRequest = {
                                            requests: this_1.formatRequests(requestsChunk),
                                        };
                                        batchOptions = {
                                            body: jsS(batchRequest),
                                            headers: {
                                                "Accept": "application/json",
                                                "Content-Type": "application/json",
                                            },
                                            method: "POST",
                                        };
                                        Logger.write("[" + this_1.batchId + "] (" + (new Date()).getTime() + ") Sending batch request.", 1 /* Info */);
                                        return [4 /*yield*/, toAbsoluteUrl(this_1.batchUrl, this_1.runtime)];
                                    case 1:
                                        queryUrl = _b.sent();
                                        return [4 /*yield*/, client.fetch(queryUrl, batchOptions)
                                                .then(function (r) { return r.json(); })
                                                .then(function (j) { return _this.parseResponse(requestsChunk, j); })
                                                .then(function (parsedResponse) {
                                                Logger.write("[" + _this.batchId + "] (" + (new Date()).getTime() + ") Resolving batched requests.", 1 /* Info */);
                                                parsedResponse.responses.reduce(function (chain, response, index) {
                                                    var request = requestsChunk[index];
                                                    Logger.write("[" + _this.batchId + "] (" + (new Date()).getTime() + ") Resolving batched request " + request.method + " " + request.url + ".", 0 /* Verbose */);
                                                    return chain.then(function () { return request.parser.parse(response).then(request.resolve).catch(request.reject); });
                                                }, Promise.resolve());
                                            }).catch(function (e) {
                                                throw e;
                                            })];
                                    case 2:
                                        _b.sent();
                                        return [2 /*return*/];
                                }
                            });
                        };
                        this_1 = this;
                        _a.label = 1;
                    case 1:
                        if (!(requests.length > 0)) return [3 /*break*/, 3];
                        return [5 /*yield**/, _loop_1()];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 1];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Urls come to the batch absolute, but the processor expects relative
     * @param url Url to ensure is relative
     */
    GraphBatch.prototype.makeUrlRelative = function (url) {
        if (!isUrlAbsolute(url)) {
            // already not absolute, just give it back
            return url;
        }
        var index = url.indexOf("/v1.0/");
        if (index < 0) {
            index = url.indexOf("/beta/");
            if (index > -1) {
                // beta url
                return url.substr(index + 6);
            }
        }
        else {
            // v1.0 url
            return url.substr(index + 5);
        }
        // no idea
        return url;
    };
    GraphBatch.prototype.formatRequests = function (requests) {
        var _this = this;
        return requests.map(function (reqInfo, index) {
            var _a;
            var requestFragment = {
                id: "" + ++index,
                method: reqInfo.method,
                url: _this.makeUrlRelative(reqInfo.url),
            };
            var headers = {};
            // merge runtime headers
            headers = assign(headers, (_a = _this.runtime.get("graph")) === null || _a === void 0 ? void 0 : _a.headers);
            if (reqInfo.options !== undefined) {
                // merge per request headers
                if (reqInfo.options.headers !== undefined && reqInfo.options.headers !== null) {
                    headers = assign(headers, reqInfo.options.headers);
                }
                // all non-get requests need their own content-type header
                if (reqInfo.method !== "GET") {
                    headers["Content-Type"] = "application/json";
                }
                // add a request body
                if (reqInfo.options.body !== undefined && reqInfo.options.body !== null) {
                    // we need to parse the body which was previously turned into a string
                    requestFragment = assign(requestFragment, {
                        body: JSON.parse(reqInfo.options.body),
                    });
                }
            }
            requestFragment = assign(requestFragment, {
                headers: headers,
            });
            return requestFragment;
        });
    };
    GraphBatch.prototype.parseResponse = function (requests, graphResponse) {
        return new Promise(function (resolve, reject) {
            // we need to see if we have an error and report that
            if (hOP(graphResponse, "error")) {
                return reject(Error("Error Porcessing Batch: (" + graphResponse.error.code + ") " + graphResponse.error.message));
            }
            var parsedResponses = new Array(requests.length).fill(null);
            for (var i = 0; i < graphResponse.responses.length; ++i) {
                var response = graphResponse.responses[i];
                // we create the request id by adding 1 to the index, so we place the response by subtracting one to match
                // the array of requests and make it easier to map them by index
                var responseId = parseInt(response.id, 10) - 1;
                if (response.status === 204) {
                    parsedResponses[responseId] = new Response();
                }
                else {
                    parsedResponses[responseId] = new Response(JSON.stringify(response.body), response);
                }
            }
            resolve({
                nextLink: graphResponse.nextLink,
                responses: parsedResponses,
            });
        });
    };
    return GraphBatch;
}(Batch));
export { GraphBatch };
//# sourceMappingURL=batch.js.map